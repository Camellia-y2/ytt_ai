# JS 执行机制
- 调用栈
   记录函数的执行顺序，管理执行上下文和变量环境
- 作用域
   变量查找的规则：
   当前作用域查找 -》 冒泡到全局没有 -》 报错 referenceError
- 作用域链
   变量查找的路径
   当前作用域 -》 上层作用域 -》 上层作用域 -》 全局作用域
- 执行上下文
   函数**调用**时创建的上下文（代码执行）对象
- 变量环境
   变量提升 var声明 
- 词法环境 (es6 新增)
   TDZ 
   let const在里面声明
   块级作用域
   outer属性 （全局作用域中，outer=NULL,最大无指向）--**es6前在变量环境中**，那时候没有词法环境，es6后在词法环境中
- 词法作用域 
   在每个执行上下文的变量环境中，都包含一个外部应用outer，用来指向外部的执行上下文。

## 作用域链
- 一段代码使用一个变量时， JS 引擎首先会在当前的执行上下文中查找该变量。
- 如果找不到，JS 引擎会继续在当前执行上下文的外部应用outer指向的执行上下文中查找该变量。
- 这个过程会一直持续到全局执行上下文。
- 如果在全局执行上下文中仍然找不到该变量，JS 引擎会抛出一个ReferenceError异常。
- 这个过程被称为**作用域链**（基于词法作用域的作用域查找规则）。

## 词法作用域
- 静态的
- 词法作用域是在代码**编译**的词法分析阶段就确定下来的作用域 ，它由代码**书写定义**时变量和块作用域的**位置**决定，一旦确定，在代码运行过程中基本保持不变 。例如在 JavaScript 中，函数在定义时就确定了它的词法作用域，与其后续的**调用位置和方式无关**。
- 预测代码在执行过程中如何查找变量


## 闭包
基础是理解词法作用域等
根据词法作用域的规则，内部函数getName和setName可以访问外部函数outer的变量name，即使外部函数outer已经执行完毕。
- 闭包是指一个函数可以访问其外部函数作用域中的变量，即使外部函数已经执行完毕。
- 闭包的形成条件
   1. 函数嵌套
   2. 内部函数引用外部函数的变量
   3. 外部函数返回内部函数

**根据词法作用域的规则，内部函数总是可以访问其外部作用域声明的变量（自由变量），当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，这些变量的集合就是闭包。**
foo 外部函数，这些变量的集合为foo函数的闭包。
这些变量的集合(**要在闭包中访问的外部函数的变量，未访问的就不算**)也是内部函数运行的专属背包。

### 闭包的作用
- 封装变量，避免全局污染
- 实现私有变量和方法


